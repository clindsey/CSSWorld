// Generated by CoffeeScript 1.4.0
(function() {

  define(["models/HeightmapChunk", "models/ViewportTile", "Alea", "Backbone"], function(HeightmapChunkModel, ViewportTileModel) {
    var Heightmap;
    Heightmap = Backbone.Model.extend({
      defaults: {
        data: void 0,
        SEED: 20130209,
        worldChunkWidth: 0,
        worldChunkHeight: 0,
        chunkWidth: 0,
        chunkHeight: 0,
        maxElevation: 0
      },
      initialize: function() {
        var chunkHeight, chunkWidth, chunks, maxElevation, worldChunkHeight, worldChunkWidth;
        worldChunkWidth = 8;
        worldChunkHeight = 8;
        chunkWidth = 9;
        chunkHeight = 9;
        maxElevation = 10;
        chunks = this.buildChunks(worldChunkWidth, worldChunkHeight, chunkWidth, chunkHeight, maxElevation);
        return this.set("data", this.generateHeightmap(chunks, worldChunkWidth * chunkWidth, worldChunkHeight * chunkHeight, chunkWidth, chunkHeight));
      },
      clamp: function(index, size) {
        return (index + size) % size;
      },
      generateHeightmap: function(chunks, worldTileWidth, worldTileHeight, chunkWidth, chunkHeight) {
        var cell, cellRow, cells, chunk, chunkRow, cx, cy, heightmap, x, xIndex, y, yIndex, _i, _j, _k, _l, _len, _len1, _len2, _len3;
        heightmap = [];
        for (y = _i = 0, _len = chunks.length; _i < _len; y = ++_i) {
          chunkRow = chunks[y];
          for (x = _j = 0, _len1 = chunkRow.length; _j < _len1; x = ++_j) {
            chunk = chunkRow[x];
            cells = chunk.get("cells");
            for (cy = _k = 0, _len2 = cells.length; _k < _len2; cy = ++_k) {
              cellRow = cells[cy];
              for (cx = _l = 0, _len3 = cellRow.length; _l < _len3; cx = ++_l) {
                cell = cellRow[cx];
                yIndex = cy + (y * cells.length);
                xIndex = cx + (x * cellRow.length);
                if (heightmap[yIndex] == null) {
                  heightmap[yIndex] = [];
                }
                heightmap[yIndex][xIndex] = new ViewportTileModel({
                  data: cell,
                  x: xIndex,
                  y: yIndex
                });
              }
            }
          }
        }
        return heightmap;
      },
      buildChunks: function(worldChunkWidth, worldChunkHeight, chunkWidth, chunkHeight, maxElevation) {
        var SEED, chunks, ne, nw, se, sw, worldTileWidth, x, y, _i, _j, _ref, _ref1;
        SEED = this.get("SEED");
        worldTileWidth = worldChunkWidth * chunkWidth;
        chunks = [];
        for (y = _i = 0, _ref = worldChunkHeight - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
          chunks[y] = [];
          for (x = _j = 0, _ref1 = worldChunkWidth - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            nw = ~~((new Alea((y * worldTileWidth + x) * SEED))() * maxElevation);
            if (x + 1 === worldChunkWidth) {
              ne = ~~((new Alea(y * worldTileWidth + SEED))() * maxElevation);
            } else {
              ne = ~~((new Alea(y * worldTileWidth + x + 1 + SEED))() * maxElevation);
            }
            if (y + 1 === worldChunkHeight) {
              sw = ~~((new Alea(x + SEED))() * maxElevation);
              if (x + 1 === worldChunkWidth) {
                se = ~~((new Alea(worldTileWidth + SEED)()) * maxElevation);
              } else {
                se = ~~((new Alea(worldTileWidth + x + 1 + SEED))() * maxElevation);
              }
            } else {
              sw = ~~((new Alea((y + 1) * worldTileWidth + x + SEED))() * maxElevation);
              if (x + 1 === worldChunkWidth) {
                se = ~~((new Alea((y + 1) * worldTileWidth + SEED))() * maxElevation);
              } else {
                se = ~~((new Alea((y + 1) * worldTileWidth + x + 1 + SEED))() * maxElevation);
              }
            }
            chunks[y][x] = new HeightmapChunkModel({
              ne: ne,
              nw: nw,
              se: se,
              sw: sw,
              width: chunkWidth,
              height: chunkHeight
            });
          }
        }
        return chunks;
      },
      getArea: function(sliceWidth, sliceHeight, centerX, centerY) {
        var dataHeight, dataOut, dataWidth, heightmapData, x, xIndex, xOffset, y, yIndex, yOffset, _i, _j, _ref, _ref1;
        dataOut = [];
        heightmapData = this.get("data");
        dataHeight = heightmapData.length;
        xOffset = sliceWidth >> 1;
        yOffset = sliceHeight >> 1;
        for (y = _i = 0, _ref = sliceHeight - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
          dataWidth = heightmapData[y].length;
          dataOut[y] = [];
          for (x = _j = 0, _ref1 = sliceWidth - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
            xIndex = this.clamp(x - xOffset + centerX, dataWidth);
            yIndex = this.clamp(y - yOffset + centerY, dataHeight);
            dataOut[y][x] = heightmapData[yIndex][xIndex];
          }
        }
        return dataOut;
      }
    });
    return new Heightmap;
  });

}).call(this);
